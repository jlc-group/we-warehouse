import { useState, useEffect } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { toast } from '@/components/ui/sonner';
import { getCurrentUserId, ensureDemoUser } from '@/utils/authHelper';

export interface SalesOrder {
  id: string;
  order_number: string;
  customer_id: string;
  subtotal: number;
  discount_amount: number;
  tax_amount: number;
  total_amount: number;
  status: 'draft' | 'confirmed' | 'picking' | 'packed' | 'shipping' | 'delivered' | 'cancelled';
  payment_status: 'pending' | 'partial' | 'paid' | 'overdue';
  order_date: string;
  required_date?: string;
  shipped_date?: string;
  delivered_date?: string;
  notes?: string;
  delivery_address?: string;
  delivery_instructions?: string;
  created_at: string;
  updated_at: string;
  created_by?: string;
  updated_by?: string;
  sales_person_id?: string;
  warehouse_person_id?: string;
  shipping_person_id?: string;

  // Relations
  customer_name?: string;
  customer_phone?: string;
  customer_email?: string;
  customer_company?: string;
}

export interface SalesOrderItem {
  id: string;
  order_id: string;
  product_id: string;
  product_name: string;
  product_sku?: string;
  quantity_cartons: number;
  quantity_boxes: number;
  quantity_pieces: number;
  total_pieces: number;
  unit_price: number;
  line_total: number;
  picked_cartons: number;
  picked_boxes: number;
  picked_pieces: number;
  total_picked: number;
  notes?: string;
  created_at: string;
  updated_at: string;
}

export interface CreateSalesOrderData {
  customer_id: string;
  subtotal: number;
  discount_amount?: number;
  tax_amount?: number;
  total_amount: number;
  notes?: string;
  delivery_address?: string;
  delivery_instructions?: string;
  required_date?: string;
  order_items: Array<{
    product_id: string;
    product_name: string;
    product_sku?: string;
    quantity_cartons: number;
    quantity_boxes: number;
    quantity_pieces: number;
    total_pieces: number;
    unit_price: number;
    line_total: number;
    notes?: string;
  }>;
}

export interface UpdateSalesOrderData extends Partial<CreateSalesOrderData> {
  status?: SalesOrder['status'];
  payment_status?: SalesOrder['payment_status'];
  shipped_date?: string;
  delivered_date?: string;
  sales_person_id?: string;
  warehouse_person_id?: string;
  shipping_person_id?: string;
}

export interface SalesOrderSearchParams {
  search?: string;
  status?: SalesOrder['status'];
  payment_status?: SalesOrder['payment_status'];
  customer_id?: string;
  date_from?: string;
  date_to?: string;
  limit?: number;
  offset?: number;
}

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
export const useSalesOrders = (params?: SalesOrderSearchParams) => {
  return useQuery({
    queryKey: ['sales-orders', params],
    queryFn: async (): Promise<SalesOrder[]> => {
      console.log('üîÑ Fetching sales orders with params:', params);

      // üéØ ‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏•‡∏≠‡∏á query: View ‚Üí Direct Table Join ‚Üí ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÉ‡∏´‡πâ fallback ‡πÄ‡∏õ‡πá‡∏ô empty

      // 1. ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ view ‡∏Å‡πà‡∏≠‡∏ô (‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)
      try {
        console.log('üîç Trying sales_orders_with_customer view...');
        const viewQuery = supabase
          .from('sales_orders_with_customer')
          .select('*')
          .order('created_at', { ascending: false });

        // Apply filters to view query
        let query = viewQuery;
        if (params?.search) {
          query = query.or(`order_number.ilike.%${params.search}%,customer_name.ilike.%${params.search}%,customer_phone.ilike.%${params.search}%`);
        }
        if (params?.status) {
          query = query.eq('status', params.status);
        }
        if (params?.payment_status) {
          query = query.eq('payment_status', params.payment_status);
        }
        if (params?.customer_id) {
          query = query.eq('customer_id', params.customer_id);
        }
        if (params?.date_from) {
          query = query.gte('order_date', params.date_from);
        }
        if (params?.date_to) {
          query = query.lte('order_date', params.date_to);
        }
        if (params?.limit) {
          query = query.limit(params.limit);
        }
        if (params?.offset) {
          query = query.range(params.offset, params.offset + (params.limit || 50) - 1);
        }

        const { data: viewData, error: viewError } = await query;

        if (!viewError && viewData) {
          console.log('‚úÖ Successfully used sales_orders_with_customer view:', viewData.length);
          return viewData;
        }

        console.warn('‚ö†Ô∏è View query failed, trying direct table join:', viewError?.message);
        throw viewError; // ‡∏Ç‡∏ß‡πâ‡∏≤‡∏á‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ó‡∏µ‡πà fallback

      } catch (viewError) {
        // 2. ‡∏ñ‡πâ‡∏≤ view ‡πÑ‡∏°‡πà‡∏°‡∏µ ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏ï‡∏≤‡∏£‡∏≤‡∏á sales_orders ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
        console.log('üîÑ Trying direct sales_orders table with customer join...');

        try {
          let directQuery = supabase
            .from('sales_orders')
            .select(`
              id,
              order_number,
              customer_id,
              customer_name,
              customer_phone,
              customer_email,
              subtotal,
              discount_amount,
              tax_amount,
              total_amount,
              status,
              payment_status,
              order_date,
              delivery_date,
              notes,
              created_at,
              updated_at,
              customers!left (
                name,
                phone,
                email,
                company_name,
                address
              )
            `)
            .order('created_at', { ascending: false });

          // Apply filters
          if (params?.search) {
            directQuery = directQuery.or(`order_number.ilike.%${params.search}%,customer_name.ilike.%${params.search}%,customer_phone.ilike.%${params.search}%`);
          }
          if (params?.status) {
            directQuery = directQuery.eq('status', params.status);
          }
          if (params?.payment_status) {
            directQuery = directQuery.eq('payment_status', params.payment_status);
          }
          if (params?.customer_id) {
            directQuery = directQuery.eq('customer_id', params.customer_id);
          }
          if (params?.date_from) {
            directQuery = directQuery.gte('order_date', params.date_from);
          }
          if (params?.date_to) {
            directQuery = directQuery.lte('order_date', params.date_to);
          }
          if (params?.limit) {
            directQuery = directQuery.limit(params.limit);
          }
          if (params?.offset) {
            directQuery = directQuery.range(params.offset, params.offset + (params.limit || 50) - 1);
          }

          const { data: directData, error: directError } = await directQuery;

          if (!directError && directData) {
            // Transform data to match expected format
            const transformedData = directData.map(order => {
              const customerData = Array.isArray(order.customers) ? order.customers[0] : order.customers;

              return {
                ...order,
                customers: undefined, // ‡∏•‡∏ö nested object
                customer_name: order.customer_name || customerData?.name || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏',
                customer_phone: order.customer_phone || customerData?.phone || '',
                customer_email: order.customer_email || customerData?.email || '',
                customer_company: customerData?.company_name || '',
                customer_address: customerData?.address || '',
              };
            });

            console.log('‚úÖ Successfully used direct table query:', transformedData.length);
            return transformedData;
          }

          console.warn('‚ö†Ô∏è Direct table query failed:', directError?.message);
          throw directError;

        } catch (directError) {
          // 3. ‡∏ñ‡πâ‡∏≤‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏‡πÅ‡∏•‡∏∞‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå
          console.error('‚ùå All queries failed. Analyzing error types...');

          const errorMessage = directError?.message || viewError?.message || 'Unknown error';
          const is404Error = errorMessage.includes('404') || errorMessage.includes('does not exist') || errorMessage.includes('relation');
          const is400Error = errorMessage.includes('400') || errorMessage.includes('relationship') || errorMessage.includes('foreign key');
          const isConnectionError = errorMessage.includes('fetch') || errorMessage.includes('network');

          if (is404Error) {
            console.warn('üîß Tables not found. Please apply migration: apply_sales_migration.sql');
            // ‡πÅ‡∏™‡∏î‡∏á toast ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å
            if (!localStorage.getItem('sales_migration_warning_shown')) {
              toast.error('‡∏£‡∏∞‡∏ö‡∏ö‡∏Ç‡∏≤‡∏¢‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á', {
                description: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏±‡∏ô apply_sales_migration.sql ‡πÉ‡∏ô Supabase Dashboard',
                duration: 10000,
                action: {
                  label: '‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å SQL',
                  onClick: () => {
                    navigator.clipboard?.writeText('-- ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå apply_sales_migration.sql ‡πÅ‡∏•‡∏∞‡∏£‡∏±‡∏ô‡πÉ‡∏ô Supabase Dashboard ‚Üí SQL Editor');
                    toast.success('‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÅ‡∏•‡πâ‡∏ß');
                  }
                }
              });
              localStorage.setItem('sales_migration_warning_shown', 'true');
            }
          } else if (is400Error) {
            console.warn('üîß Foreign key relationships issue.');
            toast.warning('‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå', {
              description: '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏±‡∏°‡∏û‡∏±‡∏ô‡∏ò‡πå‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á',
              duration: 5000
            });
          } else if (isConnectionError) {
            toast.error('‡πÄ‡∏Å‡∏¥‡∏î‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠', {
              description: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
              duration: 5000
            });
          } else {
            console.error('üî• Unexpected error:', directError, viewError);
            toast.error('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÑ‡∏°‡πà‡∏Ñ‡∏≤‡∏î‡∏Ñ‡∏¥‡∏î', {
              description: errorMessage.substring(0, 100),
              duration: 5000
            });
          }

          // Return empty array
          return [] as SalesOrder[];
        }
      }
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
};

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
export const useSalesOrder = (id: string) => {
  return useQuery({
    queryKey: ['sales-order', id],
    queryFn: async (): Promise<SalesOrder | null> => {
      if (!id) return null;

      const { data, error } = await supabase
        .from('sales_orders_with_customer')
        .select('*')
        .eq('id', id)
        .single();

      if (error) {
        if (error.code === 'PGRST116') return null; // Not found
        throw new Error(`Error fetching sales order: ${error.message}`);
      }

      return data;
    },
    enabled: !!id,
  });
};

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
export const useSalesOrderItems = (orderId: string) => {
  return useQuery({
    queryKey: ['sales-order-items', orderId],
    queryFn: async (): Promise<SalesOrderItem[]> => {
      if (!orderId) return [];

      const { data, error } = await supabase
        .from('sales_order_items')
        .select('*')
        .eq('order_id', orderId)
        .order('created_at', { ascending: true });

      if (error) {
        throw new Error(`Error fetching order items: ${error.message}`);
      }

      return data || [];
    },
    enabled: !!orderId,
  });
};

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡πÉ‡∏´‡∏°‡πà
export const useCreateSalesOrder = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (orderData: CreateSalesOrderData): Promise<SalesOrder> => {
      console.log('üõí Creating sales order with data:', orderData);

      try {
        // ‡πÉ‡∏ä‡πâ auth helper ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ authentication
        ensureDemoUser(); // ‡∏™‡∏£‡πâ‡∏≤‡∏á demo user ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ
        const userId = await getCurrentUserId();

        console.log('üîê Using user ID for order creation:', userId);

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏´‡∏•‡∏±‡∏Å
        const { data: order, error: orderError } = await supabase
          .from('sales_orders')
          .insert({
            customer_id: orderData.customer_id,
            subtotal: orderData.subtotal,
            discount_amount: orderData.discount_amount || 0,
            tax_amount: orderData.tax_amount || 0,
            total_amount: orderData.total_amount,
            notes: orderData.notes,
            delivery_address: orderData.delivery_address,
            delivery_instructions: orderData.delivery_instructions,
            required_date: orderData.required_date,
            created_by: userId,
            updated_by: userId,
            sales_person_id: userId,
          })
          .select()
          .single();

        if (orderError) {
          console.error('‚ùå Error creating sales order:', orderError);

          // ‡∏ñ‡πâ‡∏≤‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ ‡πÉ‡∏´‡πâ fallback ‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ó‡∏ô
          if (orderError.message.includes('relation "sales_orders" does not exist')) {
            console.warn('‚ö†Ô∏è Sales orders table not found - please apply migration 20250929_create_sales_system.sql');
            throw new Error('‡∏£‡∏∞‡∏ö‡∏ö‡∏Ç‡∏≤‡∏¢‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤ apply migration ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô');
          }

          throw new Error(`Error creating sales order: ${orderError.message}`);
        }

        console.log('‚úÖ Created sales order:', order);

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤
        if (orderData.order_items.length > 0) {
          const { error: itemsError } = await supabase
            .from('sales_order_items')
            .insert(
              orderData.order_items.map(item => ({
                order_id: order.id,
                product_id: item.product_id,
                product_name: item.product_name,
                product_sku: item.product_sku,
                quantity_cartons: item.quantity_cartons,
                quantity_boxes: item.quantity_boxes,
                quantity_pieces: item.quantity_pieces,
                total_pieces: item.total_pieces,
                unit_price: item.unit_price,
                line_total: item.line_total,
                notes: item.notes,
              }))
            );

          if (itemsError) {
            console.error('‚ùå Error creating order items:', itemsError);
            throw new Error(`Error creating order items: ${itemsError.message}`);
          }

          console.log('‚úÖ Created order items:', orderData.order_items.length);
        }

        return order;

      } catch (error) {
        console.error('‚ùå Failed to create sales order:', error);
        throw error;
      }
    },
    onSuccess: (newOrder) => {
      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï cache
      queryClient.invalidateQueries({ queryKey: ['sales-orders'] });

      toast.success('‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß', {
        description: `‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà: ${newOrder.order_number}`,
      });
    },
    onError: (error) => {
      toast.error('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠', {
        description: error.message,
      });
    },
  });
};

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
export const useUpdateSalesOrder = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id, ...updateData }: UpdateSalesOrderData & { id: string }): Promise<SalesOrder> => {
      const { data: { user } } = await supabase.auth.getUser();

      const { data, error } = await supabase
        .from('sales_orders')
        .update({
          ...updateData,
          updated_by: user?.id,
        })
        .eq('id', id)
        .select()
        .single();

      if (error) {
        throw new Error(`Error updating sales order: ${error.message}`);
      }

      return data;
    },
    onSuccess: (updatedOrder) => {
      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï cache
      queryClient.invalidateQueries({ queryKey: ['sales-orders'] });
      queryClient.invalidateQueries({ queryKey: ['sales-order', updatedOrder.id] });

      toast.success('‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß', {
        description: `‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà: ${updatedOrder.order_number}`,
      });
    },
    onError: (error) => {
      toast.error('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠', {
        description: error.message,
      });
    },
  });
};

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
export const useCancelSalesOrder = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (id: string): Promise<void> => {
      const { data: { user } } = await supabase.auth.getUser();

      const { error } = await supabase
        .from('sales_orders')
        .update({
          status: 'cancelled',
          updated_by: user?.id,
        })
        .eq('id', id);

      if (error) {
        throw new Error(`Error cancelling sales order: ${error.message}`);
      }
    },
    onSuccess: () => {
      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï cache
      queryClient.invalidateQueries({ queryKey: ['sales-orders'] });

      toast.success('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
    },
    onError: (error) => {
      toast.error('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠', {
        description: error.message,
      });
    },
  });
};

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠ (real-time search)
export const useSalesOrderSearch = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState('');

  // Debounce search term
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedSearchTerm(searchTerm);
    }, 300);

    return () => clearTimeout(timer);
  }, [searchTerm]);

  const { data: orders, isLoading } = useSalesOrders({
    search: debouncedSearchTerm,
    limit: 20,
  });

  return {
    searchTerm,
    setSearchTerm,
    orders: orders || [],
    isLoading,
  };
};

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
export const useSalesOrderStats = () => {
  return useQuery({
    queryKey: ['sales-order-stats'],
    queryFn: async () => {
      const [
        { count: totalOrders },
        { count: draftOrders },
        { count: confirmedOrders },
        { count: deliveredOrders },
        { count: cancelledOrders },
        { data: revenueData }
      ] = await Promise.all([
        supabase.from('sales_orders').select('*', { count: 'exact', head: true }),
        supabase.from('sales_orders').select('*', { count: 'exact', head: true }).eq('status', 'draft'),
        supabase.from('sales_orders').select('*', { count: 'exact', head: true }).eq('status', 'confirmed'),
        supabase.from('sales_orders').select('*', { count: 'exact', head: true }).eq('status', 'delivered'),
        supabase.from('sales_orders').select('*', { count: 'exact', head: true }).eq('status', 'cancelled'),
        supabase
          .from('sales_orders')
          .select('total_amount')
          .eq('status', 'delivered')
          .gte('order_date', new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString().split('T')[0])
      ]);

      const monthlyRevenue = revenueData?.reduce((sum, order) => sum + (order.total_amount || 0), 0) || 0;

      return {
        total: totalOrders || 0,
        draft: draftOrders || 0,
        confirmed: confirmedOrders || 0,
        delivered: deliveredOrders || 0,
        cancelled: cancelledOrders || 0,
        monthlyRevenue,
      };
    },
    staleTime: 10 * 60 * 1000, // 10 minutes
  });
};

// Utility functions
export const formatOrderStatus = (status: SalesOrder['status']): string => {
  const statusMap = {
    draft: '‡∏£‡πà‡∏≤‡∏á',
    confirmed: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÅ‡∏•‡πâ‡∏ß',
    picking: '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏à‡∏±‡∏î‡πÄ‡∏Å‡πá‡∏ö',
    packed: '‡πÅ‡∏û‡πá‡∏Ñ‡πÄ‡∏™‡∏£‡πá‡∏à',
    shipping: '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏à‡∏±‡∏î‡∏™‡πà‡∏á',
    delivered: '‡∏à‡∏±‡∏î‡∏™‡πà‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à',
    cancelled: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
  };
  return statusMap[status] || status;
};

export const formatPaymentStatus = (status: SalesOrder['payment_status']): string => {
  const statusMap = {
    pending: '‡∏£‡∏≠‡∏ä‡∏≥‡∏£‡∏∞',
    partial: '‡∏ä‡∏≥‡∏£‡∏∞‡∏ö‡∏≤‡∏á‡∏™‡πà‡∏ß‡∏ô',
    paid: '‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô',
    overdue: '‡πÄ‡∏Å‡∏¥‡∏ô‡∏Å‡∏≥‡∏´‡∏ô‡∏î',
  };
  return statusMap[status] || status;
};

export const getOrderStatusColor = (status: SalesOrder['status']): string => {
  const colorMap = {
    draft: 'bg-gray-100 text-gray-800',
    confirmed: 'bg-blue-100 text-blue-800',
    picking: 'bg-yellow-100 text-yellow-800',
    packed: 'bg-purple-100 text-purple-800',
    shipping: 'bg-orange-100 text-orange-800',
    delivered: 'bg-green-100 text-green-800',
    cancelled: 'bg-red-100 text-red-800',
  };
  return colorMap[status] || 'bg-gray-100 text-gray-800';
};

export const getPaymentStatusColor = (status: SalesOrder['payment_status']): string => {
  const colorMap = {
    pending: 'bg-yellow-100 text-yellow-800',
    partial: 'bg-orange-100 text-orange-800',
    paid: 'bg-green-100 text-green-800',
    overdue: 'bg-red-100 text-red-800',
  };
  return colorMap[status] || 'bg-gray-100 text-gray-800';
};

export default {
  useSalesOrders,
  useSalesOrder,
  useSalesOrderItems,
  useCreateSalesOrder,
  useUpdateSalesOrder,
  useCancelSalesOrder,
  useSalesOrderSearch,
  useSalesOrderStats,
  formatOrderStatus,
  formatPaymentStatus,
  getOrderStatusColor,
  getPaymentStatusColor,
};