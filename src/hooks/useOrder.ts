import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import type {
  CustomerOrder,
  CustomerOrderInsert,
  CustomerOrderUpdate,
  OrderItem,
  OrderItemInsert,
  OrderItemUpdate
} from '@/integrations/supabase/types';
import { toast } from 'sonner';
import { deductStock, validateStock } from './useStockManagement';

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
export function useOrders(customerId?: string, warehouseId?: string) {
  return useQuery({
    queryKey: ['orders', customerId, warehouseId],
    queryFn: async () => {
      console.log('üîç Fetching orders...', { customerId, warehouseId });

      let query = supabase
        .from('customer_orders')
        .select(`
          *,
          customers (
            customer_name,
            customer_code,
            customer_type
          ),
          warehouses (
            name,
            code
          )
        `)
        .order('created_at', { ascending: false });

      if (customerId) {
        query = query.eq('customer_id', customerId);
      }

      if (warehouseId) {
        query = query.eq('warehouse_id', warehouseId);
      }

      const { data, error } = await query;

      if (error) {
        console.error('‚ùå Error fetching orders:', error);
        throw error;
      }

      console.log(`‚úÖ Fetched ${data?.length || 0} orders`);
      return data as any[]; // CustomerOrder with joined data
    },
  });
}

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤
export function useOrder(orderId?: string) {
  return useQuery({
    queryKey: ['order', orderId],
    queryFn: async () => {
      if (!orderId) return null;

      console.log('üîç Fetching order:', orderId);

      const { data, error } = await supabase
        .from('customer_orders')
        .select(`
          *,
          customers (
            customer_name,
            customer_code,
            customer_type,
            phone,
            email
          ),
          warehouses (
            name,
            code
          ),
          order_items (
            *,
            inventory_items (
              product_name,
              sku,
              location
            )
          )
        `)
        .eq('id', orderId)
        .single();

      if (error) {
        console.error('‚ùå Error fetching order:', error);
        throw error;
      }

      console.log('‚úÖ Fetched order:', data.order_number);
      return data as any; // CustomerOrder with joined data
    },
    enabled: !!orderId,
  });
}

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
export function useOrderItems(orderId?: string) {
  return useQuery({
    queryKey: ['order-items', orderId],
    queryFn: async () => {
      if (!orderId) return [];

      console.log('üîç Fetching order items:', orderId);

      const { data, error } = await supabase
        .from('order_items')
        .select(`
          *,
          inventory_items (
            id,
            product_name,
            sku,
            location,
            warehouse_id
          )
        `)
        .eq('order_id', orderId)
        .order('line_number');

      if (error) {
        console.error('‚ùå Error fetching order items:', error);
        throw error;
      }

      console.log(`‚úÖ Fetched ${data?.length || 0} order items`);
      return data as any[]; // OrderItem with joined data
    },
    enabled: !!orderId,
  });
}

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
export function useOrderStats(customerId?: string, warehouseId?: string) {
  return useQuery({
    queryKey: ['order-stats', customerId, warehouseId],
    queryFn: async () => {
      console.log('üìä Fetching order stats...', { customerId, warehouseId });

      let query = supabase
        .from('customer_orders')
        .select('id, status, final_amount, created_at');

      if (customerId) {
        query = query.eq('customer_id', customerId);
      }

      if (warehouseId) {
        query = query.eq('warehouse_id', warehouseId);
      }

      const { data, error } = await query;

      if (error) {
        console.error('‚ùå Error fetching order stats:', error);
        throw error;
      }

      // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
      const totalOrders = data?.length || 0;
      const totalAmount = data?.reduce((sum, order) => sum + (order.final_amount || 0), 0) || 0;

      const statusCounts = data?.reduce((counts, order) => {
        const status = order.status || 'DRAFT';
        counts[status] = (counts[status] || 0) + 1;
        return counts;
      }, {} as Record<string, number>) || {};

      const stats = {
        totalOrders,
        totalAmount,
        averageOrderValue: totalOrders > 0 ? totalAmount / totalOrders : 0,
        statusCounts,
        drafts: statusCounts['DRAFT'] || 0,
        confirmed: statusCounts['CONFIRMED'] || 0,
        processing: statusCounts['PROCESSING'] || 0,
        ready: statusCounts['READY'] || 0,
        shipped: statusCounts['SHIPPED'] || 0,
        delivered: statusCounts['DELIVERED'] || 0,
        cancelled: statusCounts['CANCELLED'] || 0,
      };

      console.log('‚úÖ Order stats:', stats);
      return stats;
    },
  });
}

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠
async function validateStockAvailability(orderItems: OrderItemInsert[]) {
  console.log('üîç Validating stock availability for', orderItems.length, 'items');

  for (const item of orderItems) {
    if (!item.inventory_item_id) {
      continue; // ‡∏Ç‡πâ‡∏≤‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ inventory_item_id
    }

    // ‡∏î‡∏∂‡∏á‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    const { data: currentItem, error } = await supabase
      .from('inventory_items')
      .select('id, product_name, sku, location, unit_level1_quantity, unit_level2_quantity, unit_level3_quantity')
      .eq('id', item.inventory_item_id)
      .single();

    if (error) {
      console.error('‚ùå Error fetching inventory for validation:', error);
      throw new Error(`‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏Ç‡∏≠‡∏á ${item.product_name}`);
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠
    const availableLevel1 = currentItem.unit_level1_quantity || 0;
    const availableLevel2 = currentItem.unit_level2_quantity || 0;
    const availableLevel3 = currentItem.unit_level3_quantity || 0;

    const itemData = item as any; // Type assertion
    const requestedLevel1 = itemData.ordered_quantity_level1 || 0;
    const requestedLevel2 = itemData.ordered_quantity_level2 || 0;
    const requestedLevel3 = itemData.ordered_quantity_level3 || 0;

    console.log('üìä Stock check:', {
      product: item.product_name,
      location: currentItem.location,
      available: { level1: availableLevel1, level2: availableLevel2, level3: availableLevel3 },
      requested: { level1: requestedLevel1, level2: requestedLevel2, level3: requestedLevel3 }
    });

    if (requestedLevel1 > availableLevel1) {
      throw new Error(`‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠: ${item.product_name} ‡∏ó‡∏µ‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á ${currentItem.location}\n‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ ${requestedLevel1} ‡∏•‡∏±‡∏á ‡πÅ‡∏ï‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏µ‡∏¢‡∏á ${availableLevel1} ‡∏•‡∏±‡∏á`);
    }

    if (requestedLevel2 > availableLevel2) {
      throw new Error(`‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠: ${item.product_name} ‡∏ó‡∏µ‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á ${currentItem.location}\n‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ ${requestedLevel2} ‡πÄ‡∏®‡∏© ‡πÅ‡∏ï‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏µ‡∏¢‡∏á ${availableLevel2} ‡πÄ‡∏®‡∏©`);
    }

    if (requestedLevel3 > availableLevel3) {
      throw new Error(`‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠: ${item.product_name} ‡∏ó‡∏µ‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á ${currentItem.location}\n‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ ${requestedLevel3} ‡∏ä‡∏¥‡πâ‡∏ô ‡πÅ‡∏ï‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏µ‡∏¢‡∏á ${availableLevel3} ‡∏ä‡∏¥‡πâ‡∏ô`);
    }
  }

  console.log('‚úÖ All stock availability validated');
}

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡πÉ‡∏´‡∏°‡πà
export function useCreateOrder() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      orderData,
      orderItems
    }: {
      orderData: CustomerOrderInsert;
      orderItems: OrderItemInsert[]
    }) => {
      console.log('üìù Creating order for customer:', orderData.customer_id);
      console.log('üìä Order data:', orderData);

      // Validate required fields
      if (!orderData.customer_id) {
        throw new Error('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤');
      }

      if (!orderData.warehouse_id) {
        throw new Error('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤');
      }

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
      await validateStockAvailability(orderItems);

      // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
      const { data: order, error: orderError } = await supabase
        .from('customer_orders')
        .insert(orderData)
        .select()
        .single();

      if (orderError) {
        console.error('‚ùå Error creating order:', orderError);

        // ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° error ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏á‡πà‡∏≤‡∏¢
        if (orderError.code === '23503') {
          throw new Error('‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: ‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö');
        } else if (orderError.code === '23505') {
          throw new Error('‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏ã‡πâ‡∏≥');
        } else {
          throw new Error(`‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡πÑ‡∏î‡πâ: ${orderError.message}`);
        }
      }

      // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤
      if (orderItems.length > 0) {
        const itemsWithOrderId = orderItems.map(item => ({
          ...item,
          order_id: order.id,
        }));

        const { error: itemsError } = await supabase
          .from('order_items')
          .insert(itemsWithOrderId);

        if (itemsError) {
          console.error('‚ùå Error creating order items:', itemsError);
          throw itemsError;
        }

        // ‡∏à‡∏≠‡∏á‡∏™‡∏ï‡πá‡∏≠‡∏Å (stock reservation) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏ó‡∏µ‡πà‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ DRAFT
        // ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏ã‡πâ‡∏≥‡∏Å‡πà‡∏≠‡∏ô‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
        if (order.status === 'DRAFT') {
          await reserveStock(order.id, orderItems);
        }
      }

      console.log('‚úÖ Order created:', order.order_number);
      return order as CustomerOrder;
    },
    onSuccess: (data) => {
      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï cache
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      queryClient.invalidateQueries({ queryKey: ['order-stats'] });
      toast.success(`‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠ "${data.order_number}" ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`);
    },
    onError: (error) => {
      console.error('‚ùå Create order failed:', error);

      // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° error ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏á‡πà‡∏≤‡∏¢
      const errorMessage = error instanceof Error ? error.message : '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠';
      toast.error(errorMessage);
    },
  });
}

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏±‡∏î‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠ - ‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà
async function deductInventoryStock(orderId: string) {
  console.log('üì¶ Starting inventory deduction for order:', orderId);

  // ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
  const { data: orderItems, error: itemsError } = await supabase
    .from('order_items')
    .select('*')
    .eq('order_id', orderId);

  if (itemsError) {
    console.error('‚ùå Error fetching order items for deduction:', itemsError);
    throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠');
  }

  if (!orderItems || orderItems.length === 0) {
    console.log('‚ÑπÔ∏è No items to deduct for order:', orderId);
    return;
  }

  // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏ï‡∏±‡∏î‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
  for (const item of orderItems) {
    if (!item.inventory_item_id) {
      console.warn('‚ö†Ô∏è No inventory_item_id for order item:', item.id);
      continue;
    }

    const itemData = item as any; // Type assertion
    
    try {
      await deductStock(item.inventory_item_id, {
        level1: itemData.ordered_quantity_level1 || 0,
        level2: itemData.ordered_quantity_level2 || 0,
        level3: itemData.ordered_quantity_level3 || 0
      });
      
      console.log('‚úÖ Stock deducted successfully for:', item.product_name);
    } catch (error) {
      console.error('‚ùå Error deducting stock:', error);
      throw error;
    }
  }

  console.log('‚úÖ All inventory deductions completed for order:', orderId);
}

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏≠‡∏á‡∏™‡∏ï‡πá‡∏≠‡∏Å (Stock Reservation) - ‡πÉ‡∏ä‡πâ notes field ‡πÅ‡∏ó‡∏ô
async function reserveStock(orderId: string, orderItems: OrderItemInsert[]) {
  console.log('üîí Starting stock reservation for order:', orderId);

  try {
    for (const item of orderItems) {
      if (!item.inventory_item_id) {
        continue; // ‡∏Ç‡πâ‡∏≤‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ inventory_item_id
      }

      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï notes ‡πÉ‡∏ô inventory_items ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡πà‡∏≤‡∏ñ‡∏π‡∏Å‡∏à‡∏≠‡∏á
      const { error: reservationError } = await supabase
        .from('inventory_items')
        .update({
          notes: `RESERVED for Order ${orderId} - ${item.product_name}`,
          updated_at: new Date().toISOString()
        })
        .eq('id', item.inventory_item_id);

      if (reservationError) {
        console.error('‚ùå Error creating stock reservation:', reservationError);
        // ‡πÑ‡∏°‡πà throw error ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß
      } else {
        console.log('üîí Stock reserved for:', item.product_name);
      }
    }

    console.log('‚úÖ Stock reservation completed for order:', orderId);
  } catch (error) {
    console.error('‚ùå Stock reservation failed:', error);
    // ‡πÑ‡∏°‡πà throw error ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß
  }
}

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á stock - ‡πÉ‡∏ä‡πâ notes field ‡πÅ‡∏ó‡∏ô
async function unreserveStock(orderId: string) {
  console.log('üîì Unreserving stock for order:', orderId);

  // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ inventory items ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏à‡∏≠‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö order ‡∏ô‡∏µ‡πâ
  const { data: reservedItems, error: fetchError } = await supabase
    .from('inventory_items')
    .select('id')
    .like('notes', `%RESERVED for Order ${orderId}%`);

  if (fetchError) {
    console.error('‚ùå Error fetching reserved items:', fetchError);
    return;
  }

  if (reservedItems && reservedItems.length > 0) {
    // ‡∏•‡πâ‡∏≤‡∏á notes ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á
    const { error } = await supabase
      .from('inventory_items')
      .update({
        notes: null,
        updated_at: new Date().toISOString()
      })
      .in('id', reservedItems.map(item => item.id));

    if (error) {
      console.error('‚ùå Error unreserving stock:', error);
    } else {
      console.log('‚úÖ Stock unreserved for order:', orderId);
    }
  }
}

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
export function useUpdateOrderStatus() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      orderId,
      status,
      notes
    }: {
      orderId: string;
      status: string;
      notes?: string
    }) => {
      console.log('üìù Updating order status:', orderId, status);

      const updates: CustomerOrderUpdate = {
        status,
        updated_at: new Date().toISOString(),
      };

      // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ï‡πà‡∏≤‡∏á‡πÜ
      if (status === 'CONFIRMED') {
        updates.confirmed_at = new Date().toISOString();
      } else if (status === 'SHIPPED') {
        updates.shipped_at = new Date().toISOString();
      } else if (status === 'DELIVERED') {
        updates.delivered_at = new Date().toISOString();
      }

      if (notes) {
        updates.internal_notes = notes;
      }

      // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ stock ‡∏ï‡∏≤‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
      if (status === 'CONFIRMED') {
        // ‡∏ï‡∏±‡∏î‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏à‡∏£‡∏¥‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
        await deductInventoryStock(orderId);
        console.log('‚úÖ Stock deducted for confirmed order:', orderId);
      } else if (status === 'CANCELLED') {
        // ‡∏õ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á stock
        await unreserveStock(orderId);
      }

      const { data, error } = await supabase
        .from('customer_orders')
        .update(updates)
        .eq('id', orderId)
        .select()
        .single();

      if (error) {
        console.error('‚ùå Error updating order status:', error);
        throw error;
      }

      console.log('‚úÖ Order status updated:', data.order_number, status);
      return data as CustomerOrder;
    },
    onSuccess: (data) => {
      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï cache
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      queryClient.invalidateQueries({ queryKey: ['order', data.id] });
      queryClient.invalidateQueries({ queryKey: ['order-stats'] });
      queryClient.invalidateQueries({ queryKey: ['inventory'] }); // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï inventory cache ‡∏î‡πâ‡∏ß‡∏¢

      const statusLabel = getOrderStatusLabel(data.status || 'DRAFT');
      let message = `‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠ "${data.order_number}" ‡πÄ‡∏õ‡πá‡∏ô ${statusLabel} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`;

      if (data.status === 'CONFIRMED') {
        message += ' ‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡∏î‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Ñ‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß';
      } else if (data.status === 'CANCELLED') {
        message += ' ‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß';
      }

      toast.success(message);
    },
    onError: (error) => {
      console.error('‚ùå Update order status failed:', error);
      const errorMessage = error instanceof Error ? error.message : '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠';
      toast.error(errorMessage);
    },
  });
}

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
export function useAddOrderItem() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (itemData: OrderItemInsert) => {
      console.log('üìù Adding item to order:', itemData.order_id);

      const { data, error } = await supabase
        .from('order_items')
        .insert(itemData)
        .select()
        .single();

      if (error) {
        console.error('‚ùå Error adding order item:', error);
        throw error;
      }

      console.log('‚úÖ Order item added:', data.sku);
      return data as OrderItem;
    },
    onSuccess: (data) => {
      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï cache
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      queryClient.invalidateQueries({ queryKey: ['order', data.order_id] });
      queryClient.invalidateQueries({ queryKey: ['order-items', data.order_id] });
      toast.success(`‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ "${data.product_name}" ‡πÉ‡∏ô‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`);
    },
    onError: (error) => {
      console.error('‚ùå Add order item failed:', error);
      toast.error('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠');
    },
  });
}

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
export function useUpdateOrderItem() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      itemId,
      updates
    }: {
      itemId: string;
      updates: OrderItemUpdate
    }) => {
      console.log('üìù Updating order item:', itemId);

      const { data, error } = await supabase
        .from('order_items')
        .update(updates)
        .eq('id', itemId)
        .select()
        .single();

      if (error) {
        console.error('‚ùå Error updating order item:', error);
        throw error;
      }

      console.log('‚úÖ Order item updated:', data.sku);
      return data as OrderItem;
    },
    onSuccess: (data) => {
      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï cache
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      queryClient.invalidateQueries({ queryKey: ['order', data.order_id] });
      queryClient.invalidateQueries({ queryKey: ['order-items', data.order_id] });
      toast.success(`‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ "${data.product_name}" ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`);
    },
    onError: (error) => {
      console.error('‚ùå Update order item failed:', error);
      toast.error('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠');
    },
  });
}

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏à‡∏≤‡∏Å‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
export function useDeleteOrderItem() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ itemId, orderId }: { itemId: string; orderId: string }) => {
      console.log('üóëÔ∏è Deleting order item:', itemId);

      const { error } = await supabase
        .from('order_items')
        .delete()
        .eq('id', itemId);

      if (error) {
        console.error('‚ùå Error deleting order item:', error);
        throw error;
      }

      console.log('‚úÖ Order item deleted');
      return { itemId, orderId };
    },
    onSuccess: (data) => {
      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï cache
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      queryClient.invalidateQueries({ queryKey: ['order', data.orderId] });
      queryClient.invalidateQueries({ queryKey: ['order-items', data.orderId] });
      toast.success('‡∏•‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏à‡∏≤‡∏Å‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
    },
    onError: (error) => {
      console.error('‚ùå Delete order item failed:', error);
      toast.error('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏à‡∏≤‡∏Å‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠');
    },
  });
}

// Hook ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
export function useCancelOrder() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ orderId, reason }: { orderId: string; reason?: string }) => {
      console.log('‚ùå Cancelling order:', orderId);

      // ‡∏õ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á stock ‡∏Å‡πà‡∏≠‡∏ô‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
      await unreserveStock(orderId);

      const updates: CustomerOrderUpdate = {
        status: 'CANCELLED',
        internal_notes: reason ? `‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å: ${reason}` : '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠',
        updated_at: new Date().toISOString(),
      };

      const { data, error } = await supabase
        .from('customer_orders')
        .update(updates)
        .eq('id', orderId)
        .select()
        .single();

      if (error) {
        console.error('‚ùå Error cancelling order:', error);
        throw error;
      }

      console.log('‚úÖ Order cancelled:', data.order_number);
      return data as CustomerOrder;
    },
    onSuccess: (data) => {
      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï cache
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      queryClient.invalidateQueries({ queryKey: ['order', data.id] });
      queryClient.invalidateQueries({ queryKey: ['order-stats'] });
      toast.success(`‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠ "${data.order_number}" ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`);
    },
    onError: (error) => {
      console.error('‚ùå Cancel order failed:', error);
      toast.error('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠');
    },
  });
}

// Utility constants
export const orderStatusOptions = [
  { value: 'DRAFT', label: '‡∏£‡πà‡∏≤‡∏á', color: 'gray' },
  { value: 'CONFIRMED', label: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÅ‡∏•‡πâ‡∏ß', color: 'blue' },
  { value: 'PROCESSING', label: '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏à‡∏±‡∏î‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°', color: 'yellow' },
  { value: 'READY', label: '‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡πà‡∏á', color: 'purple' },
  { value: 'SHIPPED', label: '‡∏à‡∏±‡∏î‡∏™‡πà‡∏á‡πÅ‡∏•‡πâ‡∏ß', color: 'orange' },
  { value: 'DELIVERED', label: '‡∏™‡πà‡∏á‡∏°‡∏≠‡∏ö‡πÅ‡∏•‡πâ‡∏ß', color: 'green' },
  { value: 'CANCELLED', label: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å', color: 'red' },
  { value: 'RETURNED', label: '‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô', color: 'red' },
];

export const orderTypeOptions = [
  { value: 'SALE', label: '‡∏Ç‡∏≤‡∏¢' },
  { value: 'TRANSFER', label: '‡πÇ‡∏≠‡∏ô' },
  { value: 'SAMPLE', label: '‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á' },
  { value: 'RETURN', label: '‡∏Ñ‡∏∑‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤' },
];

export const priorityOptions = [
  { value: 'LOW', label: '‡∏ï‡πà‡∏≥', color: 'gray' },
  { value: 'NORMAL', label: '‡∏õ‡∏Å‡∏ï‡∏¥', color: 'blue' },
  { value: 'HIGH', label: '‡∏™‡∏π‡∏á', color: 'orange' },
  { value: 'URGENT', label: '‡πÄ‡∏£‡πà‡∏á‡∏î‡πà‡∏ß‡∏ô', color: 'red' },
];

export function getOrderStatusLabel(status: string) {
  const option = orderStatusOptions.find(opt => opt.value === status);
  return option ? option.label : status;
}

export function getOrderStatusColor(status: string) {
  const option = orderStatusOptions.find(opt => opt.value === status);
  return option ? option.color : 'gray';
}

export function getPriorityLabel(priority: string) {
  const option = priorityOptions.find(opt => opt.value === priority);
  return option ? option.label : priority;
}

export function getPriorityColor(priority: string) {
  const option = priorityOptions.find(opt => opt.value === priority);
  return option ? option.color : 'gray';
}